## Today I Learned

### [React Query] [Next.js] React Query의 캐싱과 Next.js 서버 사이드 캐싱은 다르다

> #### React Query :: 클라이언트 사이드

- 위치 : 브라우저 메모리

- 범위 : 사용자별로 독립적 (로그인하는 user, 환경별로 달라짐)

- 저장소 : JavaScript 메모리 (QueryClient 인스턴스)
  ```tsx
  // useReactQueryProviders.tsx
  const [queryClient] = useState(() => new QueryClient({...}));
  ```
- 생명주기
  - 페이지 새로고침
  - gcTime(구 cacheTime)
  - 브라우저 (재)구동

<br />

> #### Next.js :: 서버 사이드

- 위치 : 서버 파일 시스템

- 범위 : 모든 사용자가 공유

- 저장소 : .next/cache/fetch-cache/ 디렉토리

- 생명주기

  - 서버 재시작 (웹 서비스 프로덕션에서는 운영중에 서버를 종료할 일이 거의 없지만, 배포시 컨테이너 교체 등으로 재시작될 수도 있다)
  - 빌드 시 초기화됨 (배포 시마다 새로 빌드하면 .next 폴더가 새로 생성되므로 ... )
  - 디스크에 저장됨
  - fetch 옵션으로 revalidate를 지정

  ```javascript
  // Next.js 15부터는 기본이 no-store
  fetch(url, {
    next: { revalidate: 3600 }, // 1시간마다 재검증
  });

  // 또는
  fetch(url, {
    cache: "force-cache", // 명시적으로 캐싱 활성화
    next: { revalidate: 3600 },
  });
  ```

<br />

> #### React Query만 사용하는 경우

1. 요청 -> 서버에서 API 호출 -> 응답 -> React Query 캐시 브라우저에 저장
2. 한 번 더 요청 -> ...
   - staleTime이 지나지 않았다면 캐시에서 즉시 반환 (서버에 API 호출 안 함)
   - staleTime이 지났다면 캐시 데이터를 먼저 보여주고 백그라운드 refetch (명시적 refetch가 아니므로 isLoading은 false, isFetching만 true)
   - React Query의 기본 staleTime은 0이므로, 기본 설정에서는 매번 백그라운드 refetch가 발생한다 ! (= 항상 즉시 stale 상태)
3. 브라우저 재시작시 캐시 사라지므로 1번부터 다시 시작

<br />

> #### Next.js 서버 캐싱과 React Query를 함께 사용하는 경우
>
> (공용 정적 데이터, 인증 불필요)

1. 최초 요청 -> 서버에서 API 호출 -> Next.js Data Cache(.next/cache)에 저장 -> prefetchQuery로 서버에서 미리 fetch -> dehydrate로 HTML에 포함 -> 클라이언트가 hydrate해서 브라우저 메모리에 저장

2. 같은 사용자의 재요청 (새로고침/재방문) -> .서버에서 .next/cache 활용 (API 호출 X) -> prefetchQuery시 캐시된 데이터 사용 -> dehydrate -> 클라이언트가 hydrate

3. 다른 사용자의 요청 -> 동일하게 .next/cache 활용 (모든 사용자가 공유) -> prefetchQuery -> dehydrate -> hydrate

+) 인증이 필요한 데이터는 모든 사용자끼리 공유되면 안되므로 Next.js 서버 캐시 사용 X, React Query만 사용하자 ~

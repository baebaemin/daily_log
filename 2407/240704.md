## TODAY I LEARNED

### [TIL-word]

- `revalidate` : 자동 갱신
- `stale` : 탁한
- `clash` : 충돌
- `mutation` : 변형, 가변 (= updata, put, delete, post 등 데이터를 변경할 때)
- `imperative` : 명령적
- `declarative` : 선언적
- `fatigue` : 피로
- `inherently` : 본질적으로
- `imperatively` : 필연적으로, 필수적으로, 불가피하게
- `examining` : 검사
- `commonality` : 공통성, 보통
- `explicitly` : 명시적으로
- `laying out` : 설계되어 있다
- `specifically` : 구체적으로
- `subjective` : 주관적인
- `take into acount` : 고려하다
- `데이터 불변성(Immutability)` : 데이터 인스턴스가 생성된 후에는 그 상태가 변하지 않는 것. 함수형 프로그래밍에서 중요시한다.
- `refers to` : ~을 참고하여
- `instance` : 사례 / 객체 지향 프로그래밍에서는 클래스의 구조로서 컴퓨터 저장공간에서 할당된 실체를 의미
- `jQuery` : 웹사이트에 자바스크립트를 쉽게 활용할 수 있도록 도와주는 오픈소스 기반의 자바스크립트 라이브러리

---

### [SWR] Stale-While-Revalidate : React Hooks for Remode Data Fetching

- HTTP 캐시 무효화 전략

- 데이터 요청시 캐시로부터 데이터(stale)를 일단 반환하고, fetch 요청(revalidate)을 보낸 후, 최신 데이터를 업데이트한다.
  => 백그라운드에서 캐시를 재검증(revalidate)하는 동안 기존의 캐시된 데이터를 사용하게 한다는 뜻.
  => error 반환시에도 캐시된 데이터를 활용할 수 있게 함으로써 데이터를 계속 호출하는데 시간을 쓰지 않음
  => (근데 특정 호출에서는 error 반환이 필요한 경우가 있지 않나 ? 아마 관련 옵션이 있겠지🤔)
- RQ처럼 포커싱을 다른 곳으로 옮겼다가 돌아오기만 해도 자동으로 재검증을 통해 업데이트를 해준다.

- SWR은 fetching에 특화된 Hook이다.
- Post가 불가한 건 아니지만 큰 이점이 없기 때문인지 (ex. post 이후 refetch) npm trends로 다운로드 횟수를 알아본 결과, tanstack/reat-query는 약 350만, swr은 약 200만 정도이다.

---

### [Programming] 순수 함수

- 사이드 이펙트가 없는 함수 (= 함수의 실행이 외부에 영향을 끼치지 않음)
- 입력으로 전달된 값을 수정하지 않는 불변성
- 어떠한 전달인자가 주어지더라도 항상 똑같은 로직에 의해 오직 함수의 입력만이 함수의 결과에 영향을 주는 함수 (= 들어온 인자가 같다면 항상 동일한 결과를 리턴)

---

### [Programming] 함수형 프로그래밍

- 성공적인 프로그래밍을 위해 side effect를 제거하고 조합성을 강조하는 프로그래밍 패러다임

  - "side effect를 제거" = "순수 함수를 만든다"

    - side effect : 리턴값으로 결과를 만드는것 외에 들어온 인자를 직접 변경하는 등 외부에 영향을 주는 것
    - 순수 함수 : 들어온 인자가 같으면 결과가 항상같은 함수

  - "조합성을 강조" = "모듈화 수준을 높힌다"
    - 모듈화 : 기능별로 코드들을 파일화하여 코드들을 구분\

- 참고 링크 : https://selgii.tistory.com/50

---

### [programming] Imperative(명령적) vs Declarative(선언적) 프로그래밍

- 언어 구분
  - Imperative
    - C
    - C++
    - Java
  - Declarative
    - HTML
    - SQL
  - Both
    - JavaScript
    - C#
    - Python
- Declarative

  - They’re concerned with `what you want to be done`, rather than how you want it done.
  - Describing what you’re trying to achieve, `without instructing how to do it`.

    ```sql
    -- SQL
    SELECT * FROM Users WHERE Country='Mexico';
    ```

    ```html
    <!-- html -->
    <article>
      <header>
        <h1>Declarative Programming</h1>
        <p>hello world !</p>
      </header>
    </article>
    ```

    Your `what` is Mexican users or a new header and paragraph on your website.

  - Many declarative approaches have some sort of imperative abstraction layer.

#### JavaScript와 jQuery의 imperative(명령적) 코드를 declarative(선언적) 코드로 바꾸기

<b>1-1. imperative js function `double`</b>

```javascript
function double(arr) {
  let results = [];
  for (let i = 0; i < arr.length; i++) {
    results.push(arr[i] * 2);
  }
  return results;
}
```

- They’re describing `HOW to do something` : Explicitly iterating over an array or explicitly laying out steps for how to implement the functionality we want.

<b>1-2. declarative js function `double`</b>

```javascript
function double(arr) {
  return arr.map((item) => item * 2);
}
```

</br>

<b>2-1. imperative js function `add`</b>

```javascript
function add(arr) {
  let result = 0;
  for (let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}
```

- They’re `mutating` some piece of state.
  - 매 반복마다 `result` 변수의 값을 변경하는 mutating이 왜 문제가 될 수 있냐면..
    - 크고 복잡한 애플리케이션에서 상태가 여러 곳에서 변경되면, 해당 상태의 현재 값이 무엇인지 파악하기 어려워진다.
    - 예상치 못한 부작용(side effects)과 버그가 발생할 수 있다.
    - 데이터 불변성(Immutability)을 중시하는 함수형 프로그래밍 원칙과 충돌한다.
  - 🤔 흐음 그런데 여기서 `let result = 0` 으로 함수가 실행될때마다 result 값을 초기화시켜주니까 side effect나 immutability는 걱정할 필요가 없지 않나?
    - => result가 0으로 초기화되기 때문에 함수 외부의 어떤 상태에도 영향을 받지 않는다는 의미에서 `순수 함수의 특성`을 가지고 있긴 하지만, 불변성을 지향하는 프로그래밍에서는 변수의 값이 바뀌지 않는 것이 좋다.
    - `함수형 프로그래밍`

<b>2-2. declarative js function `add`</b>

```javascript
function add(arr) {
  return arr.reduce((acc, cur) => acc + cur, 0);
}
```

- `result`의 값을 직접 변경하지 않고 새로운 값을 반환하는 방식으로 작성
- 원본 배열 `arr`를 변경하지 않고, `acc`의 상태를 직접 변경하는 것이 아니라 새로운 값을 반환하여 누적

</br></br>

- 읽으면서 든 생각 : modern javascript 문법에 익숙해지면 익숙해질수록 선언적 프로그래밍이 가능해지겠다.

---

### [Database] 스키마(schema)와 인스턴스(instance)

- `스키마(schema)` : 특정 데이터베이스에 대한 전반적인 설명으로, 저장되는 데이터 구조와 제약조건을 정의한 것

- `인스턴스(instance)` : 데이터베이스가 특정 순간(= 고정적이지 않은 기간)에 저장하는 정보의 모음. 정의된 스키마에 따라 데이터베이스에 실제로 저장된 값.
- 참고 링크 1 : https://byjus.com/gate/difference-between-schema-and-instance-in-dbms/
  </br>참고 링크 2 : https://computer-science-student.tistory.com/478

---

### [Process] Test-driven Development : 테스트 주도 개발(TDD)

- 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스
- 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다.
- 그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다.
- 작성한 코드를 표준에 맞도록 리팩토링한다.
- 출처 : https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C

---

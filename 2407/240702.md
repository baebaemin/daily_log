## TODAY I LEARNED

### [TIL-word]

- `blocking` : 동기 처리.

- `non-blocking` : 비동기 처리. 요청을 모두 접수하고 응답을 기다리는 동안 다른 작업을 할 수 있게 하여 빨리 완료된 순서대로 처리. Node.js에서는 파일 시스템 접근이나 네트워크 요청 같은 `I/O 작업`을 논블로킹으로 처리한다. 이러한 과정에서 이벤트 루프를 사용하여 서버의 전체적인 작동을 멈추게 하지 않는다. (참고링크 : [here](https://velog.io/@newsilver1028/Node.js-study-3%EC%A3%BC%EC%B0%A8-%EB%B9%84%EB%8F%99%EA%B8%B0-non-blocking-IO-single-thread-%EC%BD%9C%EC%8A%A4%ED%83%9D-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EB%A9%94%EC%84%B8%EC%A7%80-%ED%81%90))

- `I/O(Input/Output) 메서드`
  - Programmed I/O : CPU가 요청을 일일히 처리. 주로 키보드, 마우스 입력처럼 단순한 연산만 처리
  - Interrupt : I/O 작업이 끝났음을 CPU에게 알림
  - DMA(Direct Memory Access) : 대량의 데이터를 전송할 때 계속 Interrupt하는 것이 아니라 DMA Controller가 이를 대신 수행하고 마지막에 Interrupt를 걸어주는 방식 (참고링크 : https://velog.io/@milkbottle0305/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-12-IO-Systems)
- 비동기 작업의 콜백함수 : 작업 요청 이후 완료시 결과나 오류 정보와 함께 자동으로 호출된다. 이를 통해 비동기 작업의 결과를 처리한다. </br></br>

---

### [React 19] startTransition

- `startTransition(() => {})`

- state update를 transition인 상태로 변환

- 인자로 들어가는 scope에는 set 기능이 calling되어 state가 update 되는 기능을 포함 (그러므로 set function에 접근 가능해야 한다 => 일부 props나 custom Hook 반환값에 대한 응답으로 `Transition`을 시작하려면 `useDefferedValue`를 사용)

- scope function을 `Transition`으로 call 하여 인자없이 바로 실행 -> 동기 작업 스케줄 업데이트

- `Transition`이 진행중임을 사용하려면 `useTransition`을 사용

- `startTransition`에 전달되는 함수는 즉시 실행되어 모든 state를 `Transition`으로 표기하므로 동기식이어야 한다. 시간차로 더 많은 state 업데이트를 수행하려 하면 (ex. Timeout) `Transition`으로 표시되지 않는다.

- `Transition`으로 marking된 state의 업데이트는 다른 state 업데이트에 의해 중단될 수 있다. 만약 Transition 안에서 특정 컴포넌트를 업데이트하는 중 리렌더링되는 동안 입력을 시작하면 React는 input state 업데이트 이후 렌더링을 이어서 진행한다.

- `Transition` 업데이트는 텍스트 입력을 제어하는 데 사용될 수 없다.

- 현재의 React는 진행중인 `Transition`이 여러 개일 경우에 일괄처리하나 향후 릴리즈에서는 변경될 가능성이 높다.

```javascript
import { startTransition } from "react";

function TabContainer() {
  const [tab, setTab] = useState("about");

  function selectTab(nextTab) {
    startTransition(() => {
      setTab(nextTab);
    });
  }
  //...
}
```

- 왜 사용할까? 🤔 :
  1. 느린 디바이스에서도 UI 업데이트의 반응성을 유지할 수 있다.
  2. 리렌더링 중일때도 UI가 반응할 수 있다. 예를들면, 사용자가 탭을 클릭했다가 마음이 바뀌어 다른 탭을 누른다면 첫 번째 리렌더링이 끝나기를 기다릴 필요가 없다.

---

### [Node.js] non-blocking I/O

- Node.js의 모든 I/O 메서드는 논블로킹인 비동기 방식을 제공하고 콜백 함수를 받는다.
- `논블로킹 I/O 모델`은 블로킹 작업들을 백그라운드에서 수행하고, 이를 비동기 콜백함수로 이벤트 루프에 전달하는 것이다.

  ```javascript
  const fs = require("fs");

  fs.readFile("/path/to/file", "utf8", function (err, data) {
    if (err) {
      console.error("Error!");
    } else {
      console.log("Success: ", data);
    }
  });

  console.log("Reading File...");
  ```

- 위의 코드에서 readFile 함수는 비동기적으로 파일을 읽으며, 파일 읽기가 끝나면 결과에 따라 다른 메세지를 출력하는 콜백 함수를 실행한다. readFile 호출이 블로킹 되지 않으므로, "Reading File..." 메시지가 파일이 읽히는 동안 출력된다.

---

### [TIL-word]

- `Product Tour`: 사용자가 제품의 가치를 빠르게 느낄 수 있도록 interaction을 제공하는 가짜 프로덕트.

---

### [Test] Test 코드 입문하기

- Manual Testing (수동 테스트)

  - 지루하고 번거롭다
  - 오류가 발생하기 쉽다
  - 종종 불완전하다

- Automated Testing (자동 테스트)

  - 초기 테스트를 적을 노력이 필요하나 그 이후엔 필요없다
  - 예측 가능하고 지속적이다
  - 높은 완성도로 많은 상황에 대해 처리할 수 있다

- Unit Test 단위 테스트

  - unit이란? : 앱에서 함수, 클래스, 컴포넌트 등에 해당하는 가장 작은 블럭을 만드는 것
  - 애플리케이션은 보통 이러한 unit들의 결합으로 구성된다.
  - 가장 작은 SW를 실행해 예상대로 동작하는지 확인
  - `Jest`, `Mocha`, `Jasmine`

- Integeration Test 통합 테스트

  - 단위 테스트와 달리 외부라이브러리까지 묶어 검증시 사용
  - 여러 모듈들을 모아 예상대로 동작하는지 확인
  - API의 호출 및 응답, DB 접근, 여러 모듈, 서로 영향을 미치는 단위에 대해 테스트
  - `SuperTest`, `Nock`

- E2E Test 종단 간 테스트 (Endpoint to EndPoint)

  - 사용자 스토리에 맞춰 수행하고 시나리오상 의도에 맞게 흘러가는지 확인 = 사용자 입장에서 테스트
  - `Puppeteer`, `Playwright`, `Cypress`

- TDD(Test-Driven Development)

  - 코드를 짤 때 작은 단위의 테스트 코드를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복해 구현
  - TDD에서의 반복 사이클
    - 앱의 코드보다 먼저 실패하는 코드를 작성한다
    - 테스트 코드가 성공하도록 하는 실제 코드를 추가한다
    - refactoring 단계로 중복 코드 제거, 일반화 등을 진행한다
  - TDD는 테스트 코드를 작성한 뒤 실제 코드를 작성한다

- 참고링크1 : https://velog.io/@qmflf556/%ED%8F%AC%EC%8A%A4%EC%BD%94x%EC%BD%94%EB%94%A9%EC%98%A8-KDT-Web-8-8%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A03-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%9E%85%EB%AC%B8
- 참고링크2 : https://2023.stateofjs.com/en-US/libraries/testing/

---

### [JavaScript] AMD (Asynchronous Module Definition)

- 비동기적 모듈 정의를 위한 표준
- 웹에서 JavaScript 파일을 비동기적으로 로드하고 사용할 수 있게 설계되었다.
- 주로 브라우저에서 사용되며, 모듈과 그 의존성이 런타임에 로드되도록 하여, 애플리케이션의 시작 속도를 향상시킬 수 있다.

---

### [JavaScript] ESM (ECMAScript Module)

- ECMAScript (JavaScript의 공식 표준)에서 정의된 모듈 시스템.
- `import`와 `export` 구문을 사용하여 모듈을 로드하고, 코드를 여러 파일로 나누어 관리할 수 있다.
- 이 모듈 시스템이 ECMAScript 2015 (ES6)에서 도입되어, 모듈 간의 명확한 종속성과 범위 분리가 가능해졌다.

---

### [JavaScript] Webpack과 Babel

- Webpack : Asset 번들러. 여러 파일(JavaScript, CSS, HTML 등)을 묶어 하나 또는 여러 개의 파일로 만든다.
- Babel : JavaScript 컴파일러. 최신 JavaScript 문법(ES6 이상)을 오래된 브라우저에서도 동작할 수 있는 하위 버전의 코드(주로 ES5)로 변환.
- 돌아보면 자꾸 까먹는 둘의 차이 ... 😓

---

### [JavaScript] esbuild

- JS 번들을 빠르게 읽을 수 있는 CLI, NPM package.
- GO 언어로 작성됨
- 코드 파싱, 출력, 소스맵 형성을 병렬로 처리

---

### [Server Tool] Vite

- 배경 : 브라우저에서 ESM(ES Module)을 지원하기 전까진 JavaScript 언어 레벨에서의 모듈화 방식이 없었다. 그런데 jQuery가 생기고 규모가 커지며 파일간 변수, 함수 등을 전달하고 받는 방법이 필요해졌다. HTML에서 script로 각 script 파일을 가져와 사용할 수 있었으나 순서에 크게 영향을 받아 script별 의존성을 파악하기 어려워졌다.
  => 그래서 소스 모듈을 브라우저에서 실행할 수 있는 파일로 크롤링, 처리, 연결하는 `번들링`이 등장하게 되었다.

- `번들링`

  - 여러 코드와 프로그램을 묶어 사용자에게 웹 애플리케이션을 제공하는 핵심 과정

  - 파일들을 압축해 크기를 줄여 실행 속도와 로딩 속도를 향상시킨다

  - 번들링된 웹 어플리케이션은 사용자가 임의로 조작할 수 없으니 무결성과 보안을 강화한다

  - JavaScript는 기본적으로 전역 범위를 갖기 때문에 여러 JS 파일이 있을 때 발생할 수 있는 변수 충돌 문제를 해결할 수 있다.

  - 모듈 번들러는 하나의 시작점 endpoint로부터 의존성을 갖는 모듈을 모두 추적해 dependency graph를 만들고 하나의 결과물을 만드는 방식으로 문제를 해결한다.

</br>

- `모듈화`

  - `Webpack`과 `Babel`이 `AMD` 및 `ESM`을 지원함으로써, 모듈화를 보다 효율적으로 수행할 수 있게 되었다.
  - 모듈은 함수와 변수를 모듈 스코프에 넣고, 각 함수는 함수 스코프를 갖는다.
  - `require`, `import`, `export 등을 통해 의존성을 파악하기 용이해졌고 코드들을 독립적으로 관리하기 쉬워졌다

- 그러나..

  - 처리해야하는 JS 모듈의 개수가 증가하면 성능 저하, 느린 피드백 현상 등이 발생한다.
  - Webpack과 같은 ESM은 처음 로컬 서버 시작시 관련 있는 모듈, 소스 코드들을 모두 번들링하여 크롤링, 빌드 작업을 마쳐야 실제 페이지를 제공할 수 있다.
  - 반면, Vite는 애플리케이션 모듈을 dependencies(개발시 내용이 바뀌지 않을 부분이므로)와 source code로 나누어 개발 서버의 시작 시간을 개선했다.
    - Go로 작성된 esbuild를 사용하여 dependencies를 사전 번들링
    - 모든 모듈을 번들링하는 것이 아니라 브라우저 요청시 소스코드를 변환, 제공

- Webpack vs Vite
  : https://enjoydev.life/blog/frontend/4-module-bundler

---

### [TypeScript] Total TypeScript

- https://www.totaltypescript.com/books/total-typescript-essentials

-

### [JavaScript] 유령 의존성(Phantom Dependency)

- NPM 및 yarn v1에서는 중복 설치를 하지 않기 위해 Hoisting 기법으로 의존성 트리를 생성한다. A (-> B(1.0) 의존) 라이브러리와 C (-> A -> B(1.0) 의존) 라이브러리 사용시 두 번 설치하지 않기 위해 A와 B(1.0)를 Hoisting한다. 만약 이 상황에서 D (-> B(2.0)) 라이브러리가 설치되어있었다면 require()으로 B(2.0)을 불러오려할 때 depth가 바뀐 B(1.0)을 가져올 수 있다. 이렇게 직접 의존하고 있지 않은 라이브러리를 require()하는 것을 `유령 의존성 (Phantom Dependency)`이라 부른다.

- 유령 의존성 현상이 발생할 때, package.json에 명시하지 않은 라이브러리를 조용히 사용할 수 있게 된다. 다른 의존성을 package.json 에서 제거했을 때 소리없이 같이 사라지기도 한다.

---

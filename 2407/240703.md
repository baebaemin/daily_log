## TODAY I LEARNED

### [TIL-word]

- `syntax sugar` : 문법 설탕 🧂 - 읽는 사람 또는 작성하는 사람이 편하게 디자인 된 문법 (참고 링크 : https://dkje.github.io/2020/09/02/SyntaxSugar/)
- `TTI(Time To Interact)` : load responsiveness(얼마나 빨리 페이지가 로드될 수 있는지 / 사용자의 interaction에 반응하는 컴포넌트를 위해 JS 코드를 얼마나 빨리 수행할 수 있는지)를 측정하는 지표. Largest Contentful Paint(LCP), Total Blocking Time(TBT), Interaction to Next Paint(INP)와 같은 metrics가 TTI보다 나은 지표이기 때문에 LightHouse10의 측정항목에서 사라졌다고 한다. (참고 링크 1 : https://web.dev/articles/tti / 참고 링크 2 : https://web.dev/articles/user-centric-performance-metrics#types_of_metrics)
- `metric` : 하드웨어나 소프트웨어에 대한 성능 측정을 위한 측정 수치 값

---

### [React] RSC(React Server Component)와 RCC(React Client Component)

- RSC : 컴포넌트가 렌더링되는 장소가 서버
  - 데이터 fetching
  - 백엔드 리소스에 직접 액세스
  - 액세스 토큰, API 키 등 민감한 정보를 서버에 보관
  - 서버에 대한 큰 종속성 유지 / 클라이언트측 JavaScript 감소
- RCC : 클라이언트가 js 번들을 다운로드 받은 후 해석
  - 상호작용 및onCLick(), onChange() 등의 이벤트 리스너 추가
  - useState, useReducer, useEffect 등 상태 및 수명 주기 효과 사용
  - 브라우저 전용 API 사용
  - 상태, 효과 또는 브라우저 전용 API에 의존하는 커스텀 훅 사용

#### RSC와 RCC가 섞인 어플리케이션 동작방식

1. 클라이언트는 해당 페이지를 띄우기 위해 서버로 요청을 날린다.
2. 서버는 컴포넌트 트리를 root부터 실행하여 직렬화된 json 객체 형태의 트리로 재구성한다. (\* 직렬화란 ? 특정 객체를 다른 컴퓨터 환경으로 전송하고 재구성할 수 있는 형태로 바꾸는 과정 (ex. JSON.stringify = 직렬화 / JSON.parse = 역직렬화))

```jsx
// JSX
<div style={{ backgroundColor: "green" }}>hello world</div>
```

```javascript
// JS
React.createElement(
  div,
  { style: { backgroundColor: "green" } },
  "hello world"
);
```

```json
// json
{
  $$typeof: Symbol(react.element),
  type: "div",
  props: { style:{backgroundColor:"green"}, children:"hello world" },
  ...
}
```

3. 하지만, function과 같은 일부 객체는 직렬화될 수 없다.

- 함수는 자신이 선언된 scope에 대한 참조를 유지하고, 그 시점의 외부 변수에 대한 참조를 기억해야 하므로 실행 컨텍스트, scope, closure까지 직렬화할 수 없기 때문

4. RCC는 곧 함수이기 때문에, 직렬화 중 RCC일 경우 건너뛰고 placeholder로 대체된다.

```json
{
  $$typeof: Symbol(react.element),
  type: {
    $$typeof: Symbol(react.module.reference),
    name: "default", //export default를 의미
    filename: "./src/ClientComponent.js" //파일 경로
  },
  props: { children: "some children" },
}
```

- 함수를 직접 참조하는 것이 아니라 module reference라고 하는 새로운 타입을 적용하고, 해당 컴포넌트의 경로를 명시함으로써 직렬화를 우회한다.

5. placeholder가 포함된 stream을 client가 전달받으면 함께 다운로드한 js bundle을 참조하여, module reference 타입이 등장할 때마다 RCC를 렌더링하여 빈 공간을 채운다. 이후 DOM에 반영하면 실제 화면이 보여지게 되는 것.

---

### [React] RSC의 제약사항

1. function과 같이 직렬화가 불가능한 객체는 prop으로 넘겨줄 수 없다. (\*예외 : 'use server'를 사용하면 RSC에서 다른 RSC로 function을 넘기는 건 가능하다.)

```javascript
// Message.server.js
import ChildComponent from "./ChildComponent.server";

function logMessage() {
  console.log("This function cannot be serialized!");
}

function Message() {
  return (
    <div>
      <h1>Hello from the server!</h1>
      {/* error */}
      <ChildComponent onClick={logMessage} />
    </div>
  );
}

export default Message;
```

- 서버에서는 데이터를 처리하고 관리하는 로직에 집중하고, 클라이언트에서는 사용자 인터랙션과 관련된 로직을 처리하도록 설계하는 것이 좋다.

```javascript
// ChildComponent.client.js
import React from "react";

function ChildComponent() {
  function handleClick() {
    console.log("This function is defined in a client component.");
  }

  return <button onClick={handleClick}>Click me!</button>;
}

export default ChildComponent;
```

---

### [Web] CDN(Content Delivery Networks)

- 이미지, 비디오, CSS 등 정적 컨텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버 네트워크로, 요청 응답 시간을 줄일 수 있다.

- 동작 방식

  - 클라이언트가 CDN 서비스 사업자가 제공하는 URL을 통해 image.png에 접근한다.
  - CDN 서버의 캐시에 해당 이미지가 없는 경우, 원본 서버에 요청을 보내 이미지를 가져온다.
  - 원본 서버로부터 이미지를 받은 CDN 서버는 파일을 캐싱하고, 클라이언트에게 반환한다.

- script 태그에 js나 라이브러리를 cdn으로 가져다 사용할 때 CDN 회사에서 열람하거나 해킹당하거나 제공 서버에 장애 발생 가능성 있으므로 주의 !

- 참고링크1 : https://co1nam.tistory.com/67
- 참고링크2 : https://seungjuitmemo.tistory.com/275

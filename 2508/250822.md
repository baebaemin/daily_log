## Today I Learned

### [Debug] ê°„í—ì ìœ¼ë¡œ Infinite Scroll ê¸°ëŠ¥ì´ ë˜ì§€ ì•ŠëŠ” ë¬¸ì œ

- useInfiniteQueryë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¤í¬ë¡¤ì´ í˜ì´ì§€ì˜ ë§¨ í•˜ë‹¨ì— ë„ì°©í•˜ë©´(=isPageEnd) hasNextPageì¼ ê²½ìš° ë‹¤ìŒ í˜ì´ì§€ë¥¼ fetchingí•´ì„œ ë¬´í•œ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆë‹¤.

```tsx
// infinite scrolling data fetch ê´€ë ¨ hook
export default function useKanbanColumn(params: ApplicantsParams) {
  const clientSearchParams = useSearchParams();
  const recIdx = useRecIdx();

  const { data, fetchNextPage, hasNextPage, refetch, isSuccess, isLoading } =
    useInfiniteQuery({
      ...queries.applicants.kanbanApplicantsList(params),
      select: (item) => ({
        pages: item.pages.map(useApplicantsListTransformer),
        pageParams: item.pageParams,
      }),
      getNexgtPageParam: (lastPage: CommonApiResponse<ApplicantsResponse>, allPages) => {
        /** í˜„ì¬ê¹Œì§€ infiniteQueryë¡œ ë¶ˆëŸ¬ì˜¨ í›„ë³´ì ë¦¬ìŠ¤íŠ¸ ìˆ˜ */
        const currentApplicantCnt =
          allPages.flatMap(
            (page: CommonApiResponse<ApplicantsResponse>) => page.result?.content
          ).length || 0;
        const totalElements = lastPage.result?.totalElements;

        return totalElements && currentApplicantCnt < totalElements
          ? allPages.length // ë‹¤ìŒ í˜ì´ì§€ ë²ˆí˜¸
          : undefined; // ë” ì´ìƒ ê°€ì ¸ì˜¬ ë°ì´í„°ê°€ ì—†ìŒ
      },
      initialPageParam: 0,
      refetchOnWindowFocus: true,
    });

  /** í›„ë³´ì ë¦¬ìŠ¤íŠ¸ ë‹¤ìŒ page fetch */
  const fetchNext = useCallback(async () => {
    const res = await fetchNextPage();
    if (res.isError) console.error(res.error);
  });

  /** í•´ë‹¹ ì „í˜•ì˜ í›„ë³´ì ë¦¬ìŠ¤íŠ¸ */
  const applyList =
    data?.pages
      .flatMap((page) => page.applyList)
      .filter((item): item is TransformedApplicantManageApplicant => !!item) ?? [];

  /** í•´ë‹¹ ì „í˜•ì˜ ì´ í›„ë³´ì ìˆ˜ */
  const totalElements = data?.pages[0].totalElements;

  return {
    fetchNext,
    hasNextPage,
    refetch,
    applyList,
    totalElements,
    isLoading,
  };
}
```

```tsx
// useKanbanColumn í›…ì„ í™œìš©í•œ ë¬´í•œ ìŠ¤í¬ë¡¤ ì ìš© ì˜ˆì‹œ
const { fetchNext, hasNextPage, refetch, applyList, totalElements, isLoading } =
  useKanbanColumn(params);

const observerRef = useRef<HTMLDivElement | null>(null);
const intersectionEntry = useIntersectionObserver(observerRef, {});
const isPageEnd = !!intersectionEntry?.isIntersecting;

/** infiniteQuery ë‹¤ìŒ page fetchì‹œ timeout ì˜µì…˜ */
useEffect(() => {
  let timerId: NodeJS.Timeout | undefined;
  // ìŠ¤í¬ë¡¤ì´ í˜ì´ì§€ ëì— ë‹¤ë‹¤ë¥¸ ìƒíƒœì¸ë° ë” fetchingí•  ë°ì´í„°ê°€ ìˆë‹¤ë©´
  if (isPageEnd && hasNextPage) {
    timerId = setTimeout(() => {
      fetchNext();
    }, 500);
  }

  return () => clearTimeout(timerId);
}, [fetchNext, hasNextPage, isPageEnd]);

/** query ë³€ê²½ì‹œ refetch */
useEffect(() => {
  if (params.pageableData?.page !== 0) refetch();
}, [params, refetch]);

return (
  <DroppableWrapper columnId={String(hiringProcessSeq)} isDroppable={isDroppable}>
    {applyList && applyList.length > 0 ? (
      <div className={cx("kanban-column-list")}>
        {applyList?.map((applicant) => (
          <KanbanCard applicant={applicant} />
        ))}
        {/* NOTE: ë‹¤ìŒ í˜ì´ì§€ë¥¼ fetchingí•˜ë„ë¡ í›„ë³´ì ë¦¬ìŠ¤íŠ¸ ë§ë¯¸ì— ë…¸ì¶œ ì‹œí‚¤ëŠ” observer */}
        <div
          ref={observerRef}
          className={cx("intersection-observer")}
          aria-hidden="true"
          role="presentation"
          tabIndex={-1}
        />
      </div>
    ) : (
      <Skeleton />
    )}
  </DroppableWrapper>
);
```

- ì„œë¹„ìŠ¤ ìš´ì˜ ë° ìœ ì§€ë³´ìˆ˜ ì¤‘ ê°€ë” ê°„í—ì ìœ¼ë¡œ ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ì•Šì•„ì„œ VOC ì˜¬ë¼ì˜¤ê¸° ì „ì— ë””ë²„ê¹… ì‹œì‘ ...
- useEffect ì•ˆì˜ fetchNext()ê°€ ë™ì‘í•˜ì§€ ì•ŠëŠ” ê²ƒì´ë¯€ë¡œ isPageEnd, hasNextPage ë‘ ê°’ì´ ì œëŒ€ë¡œ ì—…ë°ì´íŠ¸ ë˜ê³  ìˆëŠ”ì§€ í™•ì¸í–ˆë‹¤. ë°ì´í„°ì™€ hasNextPage íŒë‹¨ë¶€ëŠ” ë¬¸ì œê°€ ì—†ì—ˆê¸° ë•Œë¬¸ì— isPageEndë¥¼ í™•ì¸í•´ë³´ë‹ˆ `intersectionEntry.isIntersecting`ì´ ê°’ì´ ì œëŒ€ë¡œ ê°±ì‹ ë˜ì§€ ì•Šê³  ìˆì—ˆë‹¤.

- intersectionEntryë¥¼ returní•˜ëŠ” useIntersectionObserver

  ```tsx
  /**
   * react-query infinity ì‚¬ìš© observer
   ** [ì°¸ì¡°] https://anywhereim.tistory.com/109
   */
  function useIntersectionObserver(
    elementRef: RefObject<Element | null>,
    { threshold = 0.1, root = null, rootMargin = "0%" }
  ) {
    const [entry, setEntry] = useState<IntersectionObserverEntry>();

    const updateEntry = ([target]: IntersectionObserverEntry[]): void => {
      setEntry(target);
    };

    useEffect(() => {
      const node = elementRef?.current;
      const hasIOSupport = !!window.IntersectionObserver;

      if (!node || !hasIOSupport) return;

      const observerParams = { threshold, root, rootMargin };
      const observer = new IntersectionObserver(updateEntry, observerParams);

      observer.observe(node);

      return () => observer.disconnect();
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [elementRef?.current, root, rootMargin, JSON.stringify(threshold)]);

    return entry;
  }

  export default useIntersectionObserver;
  ```

- ê°„í—ì ìœ¼ë¡œ ë°œìƒí•˜ëŠ” ë¬¸ì œë¼ ìŠ¤í¬ë¡¤ì„ ë„ˆë¬´ ë¹¨ë¦¬ ë‚´ë ¸ì„ë•Œ ì¸ì‹ì„ ëª»í•˜ë‚˜ ì‹¶ì—ˆì§€ë§Œ ê·¸ê²ƒë„ ì•„ë‹ˆê³  ... ğŸ™„ useIntersectionObserver í›…ì— threshold, root, rootMargin ë“± ì˜µì…˜ê°’ë„ ì´ëŸ°ì €ëŸ° ë²”ìœ„ë¡œ ì„¤ì •í•´ë³´ì•˜ëŠ”ë° ê°œì„ ë˜ì§€ ì•Šì•˜ë‹¤. refê°€ ì—°ê²°ëœ divì˜ z-indexë„ ì—„ì²­ í¬ê²Œ ì ìš©í•´ë´¤ì§€ë§Œ no...ğŸ™…ğŸ»â€â™€ï¸

- ë°œê²¬í•œ ì›ì¸ : intersectionEntry.isIntersectingì´ ë¬¸ì œê°€ ì•„ë‹ˆë¼ observerRefê°€ ì—°ê²°ë˜ì§€ ì•ŠëŠ” íƒ€ì´ë° ë¬¸ì œì˜€ìŒ

  - observerRefê°€ ì—°ê²°ë  intersectorëŠ” applyList && applyList.length > 0 ì´ë¼ëŠ” ì¡°ê±´í•˜ì— DOMì´ ìƒì„±ë˜ëŠ”ë°, applyListë¥¼ ê°€ì ¸ì˜¤ëŠ” ìš”ì²­ ì‘ë‹µì´ isLoadingì¼ ê²½ìš° ìŠ¤ì¼ˆë ˆí†¤ UIê°€ ëŒ€ì‹  ìƒì„±ë˜ì–´ observerRefê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ë˜ ê²ƒì´ë‹¤

- í•´ê²° ë°©ë²• (1) : isPageEnd ê°’ì„ ì—…ë°ì´íŠ¸ ì‹œì¼œì£¼ê¸° ìœ„í•´ stateì™€ effect ì‚¬ìš©

  ```tsx
  // observing ì‹œì‘í•  ìˆ˜ ìˆëŠ” ì¡°ê±´ state ì¶”ê°€
  const [isObserverReady, setIsObserverReady] = useState(false);
  const observerRef = useRef<HTMLDivElement | null>(null);
  const pageEndEntry = useIntersectionObserver(observerRef, {});
  const isPageEnd = isObserverReady && !!pageEndEntry?.isIntersecting;

  // isLoadingì´ falseê°€ ë˜ë©´ observerë¥¼ í™œì„±í™”
  useEffect(() => {
    if (!isLoading) {
      setShouldObserve(true);
    }
  }, [isLoading]);
  ```

- í•´ê²° ë°©ë²• (2) : useMemoë¡œ ëŒ€ì²´
  ```tsx
  const observerRef = useRef<HTMLDivElement | null>(null);
  const pageEndEntry = useIntersectionObserver(observerRef, {});
  const isPageEnd = useMemo(
    () => !isLoading && !!pageEndEntry?.isIntersecting,
    [isLoading, pageEndEntry?.isIntersecting]
  );
  ```

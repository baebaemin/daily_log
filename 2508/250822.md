## Today I Learned

### [Debug] 간헐적으로 Infinite Scroll 기능이 되지 않는 문제

- useInfiniteQuery를 사용하여 스크롤이 페이지의 맨 하단에 도착하면(=isPageEnd) hasNextPage일 경우 다음 페이지를 fetching해서 무한 스크롤 기능을 구현했다.

```tsx
// infinite scrolling data fetch 관련 hook
export default function useKanbanColumn(params: ApplicantsParams) {
  const clientSearchParams = useSearchParams();
  const recIdx = useRecIdx();

  const { data, fetchNextPage, hasNextPage, refetch, isSuccess, isLoading } =
    useInfiniteQuery({
      ...queries.applicants.kanbanApplicantsList(params),
      select: (item) => ({
        pages: item.pages.map(useApplicantsListTransformer),
        pageParams: item.pageParams,
      }),
      getNexgtPageParam: (lastPage: CommonApiResponse<ApplicantsResponse>, allPages) => {
        /** 현재까지 infiniteQuery로 불러온 후보자 리스트 수 */
        const currentApplicantCnt =
          allPages.flatMap(
            (page: CommonApiResponse<ApplicantsResponse>) => page.result?.content
          ).length || 0;
        const totalElements = lastPage.result?.totalElements;

        return totalElements && currentApplicantCnt < totalElements
          ? allPages.length // 다음 페이지 번호
          : undefined; // 더 이상 가져올 데이터가 없음
      },
      initialPageParam: 0,
      refetchOnWindowFocus: true,
    });

  /** 후보자 리스트 다음 page fetch */
  const fetchNext = useCallback(async () => {
    const res = await fetchNextPage();
    if (res.isError) console.error(res.error);
  });

  /** 해당 전형의 후보자 리스트 */
  const applyList =
    data?.pages
      .flatMap((page) => page.applyList)
      .filter((item): item is TransformedApplicantManageApplicant => !!item) ?? [];

  /** 해당 전형의 총 후보자 수 */
  const totalElements = data?.pages[0].totalElements;

  return {
    fetchNext,
    hasNextPage,
    refetch,
    applyList,
    totalElements,
    isLoading,
  };
}
```

```tsx
// useKanbanColumn 훅을 활용한 무한 스크롤 적용 예시
const { fetchNext, hasNextPage, refetch, applyList, totalElements, isLoading } =
  useKanbanColumn(params);

const observerRef = useRef<HTMLDivElement | null>(null);
const intersectionEntry = useIntersectionObserver(observerRef, {});
const isPageEnd = !!intersectionEntry?.isIntersecting;

/** infiniteQuery 다음 page fetch시 timeout 옵션 */
useEffect(() => {
  let timerId: NodeJS.Timeout | undefined;
  // 스크롤이 페이지 끝에 다다른 상태인데 더 fetching할 데이터가 있다면
  if (isPageEnd && hasNextPage) {
    timerId = setTimeout(() => {
      fetchNext();
    }, 500);
  }

  return () => clearTimeout(timerId);
}, [fetchNext, hasNextPage, isPageEnd]);

/** query 변경시 refetch */
useEffect(() => {
  if (params.pageableData?.page !== 0) refetch();
}, [params, refetch]);

return (
  <DroppableWrapper columnId={String(hiringProcessSeq)} isDroppable={isDroppable}>
    {applyList && applyList.length > 0 ? (
      <div className={cx("kanban-column-list")}>
        {applyList?.map((applicant) => (
          <KanbanCard applicant={applicant} />
        ))}
        {/* NOTE: 다음 페이지를 fetching하도록 후보자 리스트 말미에 노출 시키는 observer */}
        <div
          ref={observerRef}
          className={cx("intersection-observer")}
          aria-hidden="true"
          role="presentation"
          tabIndex={-1}
        />
      </div>
    ) : (
      <Skeleton />
    )}
  </DroppableWrapper>
);
```

- 서비스 운영 및 유지보수 중 가끔 간헐적으로 다음 페이지를 불러오지 않아서 VOC 올라오기 전에 디버깅 시작 ...
- useEffect 안의 fetchNext()가 동작하지 않는 것이므로 isPageEnd, hasNextPage 두 값이 제대로 업데이트 되고 있는지 확인했다. 데이터와 hasNextPage 판단부는 문제가 없었기 때문에 isPageEnd를 확인해보니 `intersectionEntry.isIntersecting`이 값이 제대로 갱신되지 않고 있었다.

- intersectionEntry를 return하는 useIntersectionObserver

  ```tsx
  /**
   * react-query infinity 사용 observer
   ** [참조] https://anywhereim.tistory.com/109
   */
  function useIntersectionObserver(
    elementRef: RefObject<Element | null>,
    { threshold = 0.1, root = null, rootMargin = "0%" }
  ) {
    const [entry, setEntry] = useState<IntersectionObserverEntry>();

    const updateEntry = ([target]: IntersectionObserverEntry[]): void => {
      setEntry(target);
    };

    useEffect(() => {
      const node = elementRef?.current;
      const hasIOSupport = !!window.IntersectionObserver;

      if (!node || !hasIOSupport) return;

      const observerParams = { threshold, root, rootMargin };
      const observer = new IntersectionObserver(updateEntry, observerParams);

      observer.observe(node);

      return () => observer.disconnect();
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [elementRef?.current, root, rootMargin, JSON.stringify(threshold)]);

    return entry;
  }

  export default useIntersectionObserver;
  ```

- 간헐적으로 발생하는 문제라 스크롤을 너무 빨리 내렸을때 인식을 못하나 싶었지만 그것도 아니고 ... 🙄 useIntersectionObserver 훅에 threshold, root, rootMargin 등 옵션값도 이런저런 범위로 설정해보았는데 개선되지 않았다. ref가 연결된 div의 z-index도 엄청 크게 적용해봤지만 no...🙅🏻‍♀️

- 발견한 원인 : intersectionEntry.isIntersecting이 문제가 아니라 observerRef가 연결되지 않는 타이밍 문제였음

  - observerRef가 연결될 intersector는 applyList && applyList.length > 0 이라는 조건하에 DOM이 생성되는데, applyList를 가져오는 요청 응답이 isLoading일 경우 스켈레톤 UI가 대신 생성되어 observerRef가 연결되지 않았던 것이다

- 해결 방법 (1) : isPageEnd 값을 업데이트 시켜주기 위해 state와 effect 사용

  ```tsx
  // observing 시작할 수 있는 조건 state 추가
  const [isObserverReady, setIsObserverReady] = useState(false);
  const observerRef = useRef<HTMLDivElement | null>(null);
  const pageEndEntry = useIntersectionObserver(observerRef, {});
  const isPageEnd = isObserverReady && !!pageEndEntry?.isIntersecting;

  // isLoading이 false가 되면 observer를 활성화
  useEffect(() => {
    if (!isLoading) {
      setShouldObserve(true);
    }
  }, [isLoading]);
  ```

- 해결 방법 (2) : useMemo로 대체
  ```tsx
  const observerRef = useRef<HTMLDivElement | null>(null);
  const pageEndEntry = useIntersectionObserver(observerRef, {});
  const isPageEnd = useMemo(
    () => !isLoading && !!pageEndEntry?.isIntersecting,
    [isLoading, pageEndEntry?.isIntersecting]
  );
  ```

## Today I Learned

### [React Query] `Optimistic Update` 낙관적 업데이트

- 후보자를 스크랩, 스크랩 해제 하는 기능을 개발 중에 낙관적 업데이트를 도입해보았다. 스크랩 POST 요청 후 쿼리 무효화로 업데이트된 후보자 정보를 받아오고 있긴 하지만 mutation 훅에서 낙관적 업데이트 처리로 즉각적인 클릭 속도를 반영하도록 한다.

```ts
/**
 * 스크랩 / 스크랩 해제
 * @request POST:/api/applicants/scrap
 * @request POST:/api/applicants/unscrap
 */
export const useScrap = (idx: number, prevScrap: boolean) => {
  const queryClient = useQueryClient();
  const params = useApplicantsListParams();

  return useMutation({
    mutationFn: (data: ScrapRequest) => (prevScrap ? postUnscrap(data) : postScrap(data)),
    // mutation이 시작되기 직전에 실행되는 콜백 함수 (Optionoal)
    // 필요에 따라 동기 / 비동기 처리가 가능하다
    onMutate: () => {
      const queryKeys = applicantsKeys.applicantsList(params);
      const previousData = queryClient.getQueryData(queryKeys);
      const newData = JSON.parse(JSON.stringify(previousData));

      // 이전 데이터의 후보자의 scrap 여부 변경
      if (newData.result?.applyList) {
        const targetIndex = newData.result.applyList.findIndex((v) => v.idx === idx);

        if (targetIndex !== -1) {
          newData.result.applyList[targetIndex].scrapCheckFl = !prevScrap;
        }
      }

      // queryData 세팅
      queryClient.setQueryData(queryKeys, newData);

      // POST가 실패했을 시 롤백하기 위해 이전 데이터를 onError와 onSettled에 전달한다
      return { previousData };
    },
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: applicantsKeys.applicantsList(idx, seq, page, size),
      });
    },
    // POST가 실패했을 시 context에 onMutate에서 전달한 previousData로 queryData 원복
    onError: (_error, _variables, context) => {
      if (context?.previousData) {
        queryClient.setQueryData(
          applicantsKeys.applicantsList(idx, seq, page, size),
          context.previousData
        );
      }
    },
  });
};
```

- 참고 링크1 : https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates
- 참고 링크2 : https://tanstack.com/query/latest/docs/framework/react/reference/useMutation

## Today I Learned

### [React Query] Proxy 기반 최적화가 깨지는 케이스

> #### 1. Object rest destructuring 사용

```js
function Parent() {
  // 이 순간 모든 속성에 접근하게 됨
  const { data, isPending, ...rest } = useQuery("users", fetchUsers);

  return <Child rest={rest} />;
}
```

- rest를 만들기 위해 JavaScript는 아래와 같이 동작하는데 ...

  ```js
  const rest = {};
  for (let key in queryResult) {
    if (key !== "data" && key !== "isPending") {
      rest[key] = queryResult[key]; // 모든 속성에 접근
    }
  }
  ```

- 위의 과정에서 접근한 속성들을 모두 추적 대상으로 등록했기 때문에 rest에 포함된 속성들 중 하나라도 변경되면 해당 컴포넌트가 리렌더링된다. = React Query의 선택적 리렌더링 최적화가 완전히 무력화됨
- rest는 프록시 트랩이 사라진 일반 객체

> #### 2. Spread operator로 새 객체 생성

```js
function Parent() {
  const queryResult = useQuery("users", fetchUsers);

  // Proxy가 풀리고 일반 객체가 됨
  return <Child queryResult={{ ...queryResult }} />;
}
```

- 스프레드 연산자는 객체의 열거 가능한(enumerable) 속성들만 복사하므로, useQuery가 반환한 proxy의 트랩은 복사되지 않는다.

> #### 3. Object.keys, Object.entries 등 사용

```js
function Parent() {
  const queryResult = useQuery("users", fetchUsers);

  // 모든 속성을 순회하게 됨
  // 1번과 마찬가지 이유로 하나라도 변경되면 keys, entries를 prop으로 전달하는 컴포넌트가 리렌더링된다.
  const keys = Object.keys(queryResult);
  const entries = Object.entries(queryResult);
}
```

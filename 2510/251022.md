## Today I Learned

### [React Query] React Query 훅이 반환하는 최상위 객체는 참조가 안정적이지 않다 !!!

```javascript
const queryResult = useQuery("users", fetchUsers);
// queryResult 자체는 매 렌더링마다 새로운 참조를 가짐

const mutationResult = useMutation(updateUser);
// mutationResult도 마찬가지

const queries = useQueries([...]);
// queries 배열도 매 렌더링마다 새로운 참조
```

- 왜냐면 ... 최상위 객체에 매번 새로운 속성들 `isLoading`, `isFetching` 등이 추가되므로 새 객체를 만드는 것이 자연스럽기 때문이다.
- 대신, 중요한 `data` 속성은 [Structural Sharing](/2510/251027.md#react-query-structural-sharing)으로 참조 안전성을 보장한다.

> #### 문제가 될 수 있는 경우

```javascript
const queryResult = useQuery("users", fetchUsers);

useEffect(() => {
  console.log("queryResult 변경됨");
}, [queryResult]);
```

부모 컴포넌트의 state가 변경되어 이곳도 리렌더링 되는 상황일 경우 ...

1. refetch가 아니지만 useQuery가 재호출되어 캐싱된 데이터를 반환한다.
2. 하지만 queryResult는 새로운 객체 참조로 반환된다.
3. useEffect가 의존성을 체크하고 콜백함수를 실행한다 ^ㅡㅠ n o . . .

> #### 바르게 사용한 경우

```javascript
const { data } = useQuery("users", fetchUsers);

useEffet(() => {
  console.log("data" 변경됨);
}, [data]); // Proxy와 관계없이
```

여기두 위와 같은 이유로 자식 컴포넌트가 리렌더링 되는 상황일 경우

1. refetch가 아니지만 useQuery가 재호출되어 캐시된 데이터를 반환한다.
2. Recat Query가 내부적으로 동일성을 유지하기 때문에 data는 같은 참조 !
3. useEffect가 의존성을 체크하고 콜백함수를 실행하지 않는다 ~~~

> #### 그럼 이 패턴은 어떨까 ??

위의 내용을 알게 된 후 작업 했던 monorepo repository에서의 useQuery 사용처들을 확인하다가, 어느 커스텀 useQuery hook에서 구조분해할당을 하지 않고 return하고 있는 패턴을 발견했다.

```javascript
// 커스텀 useQuery 훅 작성
export const useMemberView = () => {
  // (...)

  const queryResult = useQuery({
    ...queries.member.hiring({ recruit }), // (queryKeyFactory 사용 중)
  });

  useEffect(() => {
    if (queryResult?.error?.message && queryResult?.error?.message.includes("403")) {
      router.push("/error/forbidden");
    }
  }, [queryResult?.error, router]);

  return queryResult;
};
```

```javascript
// 사용처
import { useMemberView } from "@/hooks/member/useMemberView";

function MemberView({ someProps }: MemberViewProps) {
  const queryResult = useMemberView();
  const { data, isPending } = queryResult;

  useEffect(() => {
    if (queryResult?.error?.message && ...) {
      // ...로직...
    }
  }, [data]);

  return <MemberPermissionHeader content={data?.content} isPending={isPending} />;
}
```

- 만약 MemberView 컴포넌트가 부모 컴포넌트 등에 의해 리렌더링이 된다면 queryResult이 캐싱된 동일값이라고 해도 참조값이 매번 바뀌므로 useEffect의 콜백함수가 불필요하게 계속 실행되고 있었던게 아닐까? 😱 걱정했으나 ...

- ... 이 경우에도 최적화는 정상 작동되고 있었다 ! React Query는 useQuery의 반환값을 Proxy 객체로 감싸기 때문 = 즉, 실제로 접근하는 속성만 추적해서, <i>사용하는</i> 속성이 변경될 때 useQuery가 새 값을 반환하고, 컴포넌트 리렌더링이 트리거된다.

> #### 최적화가 정상 작동하는 경우

```javascript
// 1. 일반 구조분해 후 특정 속성만 접근
const { data, isPending } = useQuery({...});

// 2. 객체를 할당한 후 ...
const queryResult = useQuery({...}); // 새로운 Proxy 객체

// 2-1 나중에 구조 분해하여 사용
const { data, isPending } = queryResult; // data, isPending은 캐시된 같은 참조

// 2-2 OR 직접 접근
// 구조분해가 아닌 직접 접근 방식은 접근할 때마다 get trap이 발동
// 결과적으로는 내부 속성을 추적하는 것이므로 최적화의 측면에선 구조분해하여 사용하는것과 동일
// 구조분해와 달리 매 렌더링마다 Proxy get trap 발동하나 실무에서는 미미한 차이
const isPending = queryResult?.isPending;
const data = queryResult?.isPending;
```

- 2번의 경우, 사용처에서 Proxy의 get trap이 발동되어 data와 isPending만 추적 대상으로 등록된다. 위의 커스텀 useQuery 훅 `useMemberView`에서 `queryResult`를 통째로 Return 한 후, 사용처 `MemberView`에서 이를 받아 구조분해하여 사용하고 있다. 구조분해한 데이터에서 추출한 data?.content와 isPending을 다시 자식 컴포넌트 props에 넘기고 있는데, 해당 속성 값이 변경될 때에만 리렌더링 되는 최적화가 가능하다.(= 즉, isRefetching, isFetching 등이 변경되어도 리렌더링 되지 않음)

- 참고로 React Query의 Proxy 추적은 렌더링 페이즈에서만 작동하므로 useEffect 내부는 추적하지 않는다.

```javascript
function Component() {
  const queryResult = useQuery({...}); // Proxy 객체 반환

  // 렌더링 중 접근 = 추적됨
  const { data } = queryResult;
  console.log(queryResult?.isPending);

  useEffect(() => {
    // 이 부분은 useEffect 내부에서 접근한 것이므로 추적 X
    if (queryResult?.error?.message && ...) {
      // ...로직....
    }
  }, [data]);

  // 렌더링 중 접근 = 추적됨
  return <div>{queryResult.data?.name}</div>;
}
```

## Today I Learned

### [JavaSript] eval()

- 문자로 표현된 JavaScript 코드를 실행하는 함수이다.
- 그러나... eval은 절대 사용하지 말것 (!!!) 보안에 아주아주 취약하다

```js
console.log(eval("2 + 2")); // 4
console.log(eval(new String("2 + 2"))); // 2 + 2
console.log(eval("2 + 2" === eval("4"))); // true
console.log(eval("2 + 2" === eval(new String("2 + 2")))); // false
```

- eval()은 인자로 받은 코드를 caller의 권한으로 수행하기 때문에 위험하다. 제3자 코드가 eval()이 호출된 위치의 스코프를 볼 수 있으며, 공격에 노출될 수 있다.

- eval의 대안으로는 window.Function 메서드를 사용하기~

  ```js
  // ex) myFunction 스코프의 secretPassword에 접근할 수 있는 권한이 있음
  function myFunction() {
    const secretPassword = "abc123";
    const userInput = prompt("코드를 입력하세요");

    // 사용자가 "console.log(secretPassword)"를 입력하면 secretPassword가 출력됨 ㅠㅠ
    eval(userInput);

    // 사용자가 "console.log(secretPassword)"를 입력하면 ReferenceError: secret is not defined (굿)
    const fn = new Function(userInput); // 전역 스코프만 접근 가능하기 때문
    fn();
  }
  ```

- 최신 JavaScript 인터프리터는 JavaScript를 Machine Language로 변환하기 때문에 변수명의 개념이 완전히 사라진다. eval을 사용하면 브라우저는 Machine Language에 해당 변수가 있는지 확인하고 값을 대입하기 위해 길고 무거운 변수명 검색을 수행해야 한다. 또한 eval()을 통해 자료형 변경 등 변수에 변화가 일어날 수 있으며, 브라우저는 이에 대응하기 위해 Machine Language를 재작성해야한다.

## <br />

### [JavaScript] 표준 내장 객체 Function

- JavaScript에서 모든 함수는 사실 Function 객체이다
- 생성자 `Function()`은 새로운 `Function` 객체를 생성한다. 생성자를 직접 호출하면 함수를 동적으로 생성할 수 있지만 보안 및 eval()과 유사한 성능 때문에 고통받을 수 있다... 하지만 eval()과 달리 `Function` 생성자는 전역 범위에서만 실행되는 함수를 생성한다.

  ```js
  const globalValue = "전역 스코프";

  function myFunction() {
    const secretPassword = "abc123";
    const userInput = prompt("코드를 입력하세요");

    // 사용자가 "console.log(secretPassword)"를 입력하면 ReferenceError: secret is not defined
    // 반면, "console.log(globalValue)"를 입력하면 "전역 스코프"가 콘솔에 출력된다
    const fn = new Function(userInput);
    fn();
  }
  ```

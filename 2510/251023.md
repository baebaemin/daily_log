## Today I Learned

### [TIL-WORDS]

- `전처리 언어(상위 언어)`: 브라우저가 직접 이해할 수 없어서 빌드 시점에 변환되어야 하는 언어
  - e.g., SaSS, SCSS, Less, TypeScript, JSX 등
- `도그푸딩(Dogfooding)`: 자체 제품이나 서비스를 직원들이 먼저 사용해보면서 품질을 테스트하고 개선하는 관행 🐶🥣

## <br/>

### [React] 디바운스 훅 Debounce Hook 동작 원리 상세

- 1년 전 날짜의 TIL 문서를 보다가 디바운스 훅 동작 순서가 헷갈려서 한 번 더 정리 ^ㅡ ^...

```ts
export default function useDebounce<T>(value: T, delay: number = 500) {
  const [debounceValue, setDebounceValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebounceValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debounceValue;
}
```

```tsx
const [value, setValue] = useState(initialKeyword);
const debouncedKeyword = useDebounce(value);

const handleSearch = () => setValue(e.target.value);

// return부의 input tag
<TextInput onChange={handleSearch} />;
```

> #### 1. 최초 렌더링

- a. `value`는 `initialKeyword`로 초기화 된다
- b. useDebounce(value) 실행
- c. `debounceValue` 상태도 `initialKeyword`로 초기화
- d. useEffect 실행으로 타이머 생성, 500ms setDebounceValue(initialKeyword) 실행 예약
- e. return debounceValue (= initialKeyword 리턴)

<br />

> #### 2. 사용자가 200ms 시점에 "A"를 입력

- a. `onChange` > `handleSearch` 실행으로 setValue("A") 호출
- b. `value` state 변경으로 리렌더링 시작 & 의존성 배열 `value`가 변경되었으므로 cleanup함수 실행 -> clearTimeout으로 기존 타이머 제거
- c. 리렌더링으로 useDebounce("A") 실행
- d. `debounceValue`는 현재 여전히 `initialKeyword` (useState의 초기값은 최초 한 번만 설정됨)
- e. 새로운 useEffect 실행으로 타이머 생성, 500ms setDebounceValue("A") 실행 예약
- f. return debounceValue (= 아직 업데이트 안 되었으므로 initialKeyword 리턴)

<br />

> #### 3. 타이머 완료 (500ms가 지날 때까지 추가 입력 없음)

- a. setTimeout 콜백 실행 -> setDebounceValue("A") 호출 // 타이머는 사라짐
- b. `debounceValue` 상태 변경 -> 컴포넌트 리렌더링
- c. `debounceValue`는 이제 "A"인 상태이고, useDebounce("A") 실행
- d. useEffect 실행으로 타이머 생성, 500ms setDebounceVallue("A") 실행 예약 (추후 실행되더라도 값이 같기 때문에 리렌더링 스킵됨)
- e. return debounceValue (= "A" 리턴)

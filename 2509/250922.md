## Today I Learned

### [TIL-WORDS]
* overhead : 특정 기능을 수행하는데 드는 간접적인 시간, 메모리 등 자원

## <br />

### [Link] Cursor와 Figma로 경험하는 Model Context Protocol(MCP)
* 링크: https://www.reese-log.com/cursor-figma-model-context-protocol
    * 디자인 시스템 > Foundation의 몇 요소의 docs가 누락되어 mcp 서버 연결 후 생성해봄

## <br />

### [scss] classnames/bind의 cx는 언제 쓰는게 좋을까?

```tsx
import styles from ".../index.module.scss";

// 직접 접근
<div className={styles["content__container"]} />

// cx 사용
import classNames from "classnames/bind";
const cx = classNames.bind(styles);

<div className={cx("content__container")}/>
```

- 바인딩 오버헤드 측면에서의 비교
    - 직접 접근 방식은 컴파일 시점에 이미 스타일 적용이 결정되었으므로 바인딩 오버헤드가 발생하지 않음 
        - 런타임 비용 : 단순 객체 접근이므로 거의 없음
        - 메모리 : 추가 할당 없음
        - `styles["content__container"]` : styles 객체에서 직접 접근하여 즉시 CSS 클래스명 반환

    - 반면 cx 바인딩 방식은 바인딩 함수를 생성(`const cx = classNames.bind(styles);`)하고, 매번 함수를 호출(`cx("content__container")`)해야 하므로 오버헤드가 발생
        - 런타임 비용 : 함수 호출 + 내부 로직(→ 내부적으로 styles["spacing-showcase"]를 찾아서 반환) 실행
        - 메모리 : 바인딩된 함수 객체 생성

- 하지만 복잡한 조건부 클래스에서는 cx가 유리하다
    ```tsx
    // 직접 접근 (복잡함)
    className={`${styles.button} ${isActive ? styles['button--active'] : ''} ${isDisabled ? styles['button--disabled'] : ''}`}

    // cx 바인딩 (깔끔함)
    className={cx("button", { 
        "button--active": isActive, 
        "button--disabled": isDisabled 
    })}
    ```

- 정적 클래스만 사용한다면 추가 라이브러리 없이 바로 사용 가능하고 오버헤드가 발생하지 않는 직접 접근 방식을 사용
- 단, 조건부/복잡한 클래스를 사용해야한다면 cx가 가독성과 유지보수성에서 유리하다.
- 사실 현대 웹앱에서는 체감할 수 없는 수준의 성능 차이를 보이기 때문에 (123902387번 렌더링 할때는 또 다르겠지만 ...) 가독성, 일관성의 측면인 개발자 경험이 더 중요할 수 있다.